\documentclass[final]{siamltex}

% for red MarginPars
\usepackage{color}

% for \boldsymbol
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}

% total number of floats allowed on a page
\setcounter{totalnumber}{100}

% float page fractions
\renewcommand{\topfraction}{0.9}
\renewcommand{\bottomfraction}{0.9}
\renewcommand{\textfraction}{0.2}

% MarginPar
\setlength{\marginparwidth}{0.75in}
\newcommand{\MarginPar}[1]{\marginpar{\vskip-\baselineskip\raggedright\tiny\sffamily\hrule\smallskip{\color{red}#1}\par\smallskip\hrule}}

% for non-stacked fractions
\newcommand{\sfrac}[2]{\mathchoice
  {\kern0em\raise.5ex\hbox{\the\scriptfont0 #1}\kern-.15em/
   \kern-.15em\lower.25ex\hbox{\the\scriptfont0 #2}}
  {\kern0em\raise.5ex\hbox{\the\scriptfont0 #1}\kern-.15em/
   \kern-.15em\lower.25ex\hbox{\the\scriptfont0 #2}}
  {\kern0em\raise.5ex\hbox{\the\scriptscriptfont0 #1}\kern-.2em/
   \kern-.15em\lower.25ex\hbox{\the\scriptscriptfont0 #2}}
  {#1\!/#2}}

\def\Ab {{\bf A}}
\def\bb {{\bf b}}
\def\Fb {{\bf F}}
\def\gb {{\bf g}}
\def\Pb {{\bf P}}
\def\rb {{\bf r}}
\def\vb {{\bf v}}
\def\Wb {{\bf W}}
\def\xb {{\bf x}}

\def\deltab {\boldsymbol{\delta}}
\def\Psib   {\boldsymbol{\Psi}}
\def\Sigmab {\boldsymbol{\Sigma}}
\def\taub   {\boldsymbol{\tau}}

\def\half   {\frac{1}{2}}
\def\myhalf {\sfrac{1}{2}}

\begin{document}

%==========================================================================
% Title
%==========================================================================
\title{Implicit Low Mach Number Binary Mixing Notes}

\maketitle

\section{Equations}
We have two incompressible fluids with densities $\bar\rho_1$ and $\bar\rho_2$, where 
each fluid does not change volume upon mixing.  Defining $\rho$ to be the density of
a mixture of these fluids, the densities of each fluid are $\rho_1 \equiv \rho c$ and 
$\rho_2 \equiv \rho(1-c)$, where $c$ is the {\it mass} fraction of the first fluid.  
Thus, $\rho = \rho_1 + \rho_2$.  Since the fluids do not change volume upon mixing, 
the equation of state will enforce that the {\it volume} fractions must sum to 1:
\begin{equation}
\frac{\rho_1}{\bar\rho_1} + \frac{\rho_2}{\bar\rho_2} =
\frac{\rho c}{\bar\rho_1} + \frac{\rho(1-c)}{\bar\rho_2} = 1 
\quad \rightarrow \quad
\rho = \left(\frac{c}{\bar\rho_1} + \frac{1-c}{\bar\rho_2}\right)^{-1}.
\end{equation}
The isothermal low Mach number equations of motion are:
\begin{eqnarray}
\partial_t\rho &=& -\nabla\cdot(\rho\vb),\\
\partial_t\rho_1 &=& -\nabla\cdot(\rho_1\vb) + \underbrace{\nabla\cdot\rho\chi\nabla c + \nabla\cdot\Psib}_{\nabla\cdot\Fb},\\
\partial_t(\rho\vb) &=& -\nabla\cdot(\rho\vb\vb^T) - \nabla\pi + \mathcal{A}_0\vb + \nabla\cdot\Sigmab + \rho\gb,
\end{eqnarray}
subject to
\begin{equation}
\nabla\cdot\vb = S \equiv \underbrace{\left(\frac{1}{\bar\rho_1}-\frac{1}{\bar\rho_2}\right)}_{-(\rho^{-1}\beta)}\nabla\cdot\Fb.
\end{equation}
Thus, $S \equiv S(\Fb)$.  The stochastic terms are:
\begin{eqnarray}
\Psib &=& \sqrt{\frac{2\chi\rho\mu_c^{-1}k_BT}{\Delta t\Delta V}}\widetilde\Wb,\label{eq:rho1 stoch}\\
\Sigmab &=& \sqrt{\frac{\eta k_B T}{\Delta t\Delta V}}\left(\Wb + \Wb^T\right),\label{eq:mom stoch}
\end{eqnarray}
where $\Wb$ and $\widetilde\Wb$ are standard white-noise random Gaussian tensor
and vector fields with uncorrelated components.  In our implementation, 
we use an ideal gas mixture for (\ref{eq:rho1 stoch}) with $\mu_c^{-1}k_BT \equiv c(1-c)$ so that
\begin{equation}
\Psib = \sqrt{\frac{2\chi\rho c(1-c)}{\Delta t\Delta V}}\widetilde\Wb
\end{equation}
Also, in (\ref{eq:mom stoch}) we use
\begin{equation}
\widehat\Wb = \sqrt{2}\left(\Wb + \Wb^T\right) \quad \rightarrow \quad
\Sigmab = \sqrt{\frac{2\eta k_B T}{\Delta t\Delta V}}\widehat\Wb,
\end{equation}
where $\widehat\Wb$ is a symmetric Gaussian random tensor field, and the
extra factor of $\sqrt{2}$ accounts for the reduction in variance due to the averaging.\\

The code has several options for the viscous stress tensor.  For ease of exposition,
we define $\mathcal{A}_0$ as a function of a velocity vector, $\vb$ (the superscript
for $\mathcal{A}_0$ indicates the temporal discretization for the transport coefficients):\\
\begin{itemize}
\item $|${\tt visc\_type}$|$=1 $\quad\rightarrow\quad \mathcal{A}_0^n\vb \equiv \nabla\cdot\beta^n\nabla\vb$.\\
\item $|${\tt visc\_type}$|$=2 $\quad\rightarrow\quad \mathcal{A}_0^n\vb \equiv \nabla\cdot\left\{\beta^n[\nabla\vb + (\nabla\vb)^T]\right\}$.\\
\item $|${\tt visc\_type}$|$=3 $\quad\rightarrow\quad \mathcal{A}_0^n\vb \equiv \nabla\cdot\left\{\beta^n[\nabla\vb + (\nabla\vb)^T] + \mathcal{I}\left(\gamma^n - \frac{2}{3}\beta^n\right)(\nabla\cdot\vb)\right\}$.\\
\end{itemize}

\section{GMRES Solver}

More details on the GMRES can be found in our upcoming preconditioner paper,
so here we only summarize some important points.
We use of GMRES solver that solves systems of the form,
\begin{equation}
\underbrace{
\left(\begin{array}{cc}
\mathcal{A} & \mathcal{G} \\
-\mathcal{D} & 0
\end{array}\right)
}_{\Ab}
\underbrace{
\left(\begin{array}{c}
\xb_{\vb} \\
x_p
\end{array}\right)
}_{\xb}
=
\underbrace{
\left(\begin{array}{c}
\bb_{\vb}\\
b_p
\end{array}\right)}_{\bb},
\end{equation}
where $\xb_\vb$ and $\bb_\vb$ are staggered quantities and $x_p$ and $b_p$ are
cell-centered quantities.  The gradient operator, $\mathcal{G}$, operates on
cell-centered data and returns a staggered field.  The divergence operator, 
$\mathcal{D}$, operates on staggered data and returns a cell-centered field.  
The Helmholtz-like operator, $\mathcal{A}$, has the general form,
$\mathcal{A} = \Theta\alpha\mathcal{I} - \mathcal{A}_0$, where
$\Theta$ is a constant parameter,
$\alpha$ is a cell-centered quantity,
$\mathcal{I}$ is the identity matrix, 
and $\mathcal{A}_0$ represents the viscous stress tensor.
Both $\mathcal{A}$ and $\mathcal{A}_0$ operate on staggered data and return
a staggered field.\\

Each residual is therefore composed of two parts, a velocity residual, $r_v$,
and a pressure residual, $r_p$.  We combine these into a total residual, 
$r=\sqrt{r_v^2 + {\tt p\_norm\_weight}^2 r_p^2}$.  We consider two
kinds of residuals, the unpreconditined residual, $r=||\Ab\xb-\bb||$, 
and the preconditioned 
residual $r_P=||\Pb^{-1}(\Ab\xb-\bb)||$.  GMRES internally {\it estimates} the 
preconditioned residual without actually computing it. This estimate 
is good if the Krylov basis is truly orthogonal but may not be very good 
if there is some degeneration in orthogonality (usually a sign of bad 
scaling or ill-conditioning). So the way the convergence testing is done 
is as follows:\\
\begin{enumerate}
\item At the beginning of every outer iteration (restart), we compute 
both the true and the preconditioned residuals (this is no extra cost 
since we need to do this anyway).\\
\item If a minimum number of total iterations have been performed, and the 
preconditioned residual is within tolerance,
$r_P < {\tt gmres\_rel\_tol}*\min(||P^{-1}b||,r_{P,\rm init})$
we terminate the GMRES iteration. If the true residual is larger than 10 
times the tolerance, we issue a warning since this means that the 
preconditioned residual is not a good indication of the 
unpreconditioned residual.\\
\item In the inner iteration, we  test the estimate of the preconditioned
residual, and if it is within tolerance, we exit the inner iteration.
This does not mean the GMRES iteration will terminate, since the actual
value of the preconditioned residual may be different.
If the maximum number of inner or outer iterations is reached we exit 
with an error message.
\end{enumerate}

\section{Algorithm}
Here is the time-advancement scheme.\\ \\
{\bf Step 0: Initialization:}\\

Initialize $\vb^{\rm init}, \rho^0, \rho_1^0, \chi^0, \eta^0, \kappa^0$, and $\pi^0$.
Then, perform projection to obtain an initial velocity field, $\vb^0$, that satisfies
\begin{equation}
\nabla\cdot\vb^0 = S(\Fb^0); \qquad 
\Fb^0 = (\rho\chi\nabla c)^0 + \underbrace{\sqrt{\frac{2\left[\chi\rho c(1-c)\right]^0}{\Delta t\Delta V}}\widetilde\Wb^0}_{\Psib^0}.
\end{equation}
We do this by solving for $\phi$ and updating $\vb^{\rm init}$ as follows:
\begin{equation}
\nabla\cdot\frac{1}{\rho^0}\nabla\phi = \nabla\cdot\vb^{\rm init} - S^0,
\end{equation}
\begin{equation}
\vb^0 = \vb^{\rm init} - \frac{1}{\rho}\nabla\phi.
\end{equation}
{\bf Step 1: Forward Euler Scalar Predictor:}\\ \\
Using
\begin{equation}
\Fb^n = (\rho\chi\nabla c)^n + \underbrace{\sqrt{\frac{2\left[\chi\rho c(1-c)\right]}{\Delta t\Delta V}}\widetilde\Wb^n}_{\Psib^n},
\end{equation}
compute an advective update,
\begin{eqnarray}
\rho^{*,n+1} &=& \rho^n + \Delta t\nabla\cdot(-\rho^n\vb^n),\\
\rho_1^{*,n+1} &=& \rho_1^n + \Delta t\nabla\cdot(-\rho_1^n\vb^n + \Fb^n).
\end{eqnarray}
Note that $\Fb^n$ has already been computed during {\bf Step 4} of the previous time step
(or the initialization {\bf Step 0} if $n=0$).\\ \\
{\bf Step 2: Crank-Nicolson Velocity Predictor:}\\ \\
First, define
\begin{equation}
S^{*,n+1} \equiv S(\Fb^{*,n+1});
\qquad
\Fb^{*,n+1} = (\rho\chi\nabla c)^{*,n+1} + \Psib^n.
\end{equation}
Then, define $\vb^{*,n+1} = \vb^n + \deltab\vb, \pi^{*,n+1} = \pi^n + \delta\pi$ and solve
for $\deltab\vb$ and $\delta\pi$:
\begin{eqnarray}
\frac{\rho^{*,n+1}(\vb^n + \deltab\vb) - \rho^n\vb^n}{\Delta t} + \nabla(\pi^n+\delta\pi) &=&\nonumber\\
&&\hspace{-1.5in}\nabla\cdot(-\rho^n\vb^n\vb^n) + \half\left[\mathcal{A}_0^n\vb^n + \mathcal{A}_0^{*,n+1}(\vb^n + \deltab\vb)\right] + \nabla\cdot\underbrace{\sqrt{\frac{2\eta^n k_B T}{\Delta t\Delta V}}\widehat\Wb^n}_{\Sigmab^n}.
\end{eqnarray}
\begin{equation}
\nabla\cdot(\vb^n+\deltab\vb) = S^{*,n+1}.
\end{equation}
We rewrite this system as
\begin{eqnarray}
\left(\frac{\rho^{*,n+1}}{\Delta t} - \half\mathcal{A}_0^{*,n+1}\right)\deltab\vb + \nabla\delta\pi &=& \frac{(\rho^n-\rho^{*,n+1})\vb^n}{\Delta t} -\nabla\pi^n\nonumber\\
&&\hspace{-0.5in}+ \nabla\cdot(-\rho^n\vb^n\vb^n) + \half\left(\mathcal{A}_0^n\vb^n + \mathcal{A}_0^{*,n+1}\vb^n\right) + \nabla\cdot\Sigmab^n,\label{eq:CN Vel Pred}
\end{eqnarray}
\begin{equation}
-\nabla\cdot\deltab\vb = \nabla\cdot\vb^n - S^{*,n+1}.
\end{equation}
Relating this to the GMRES solver, we can see that we are solving for 
$(\xb_\vb,x_p) = (\deltab\vb,\delta\pi)$ with $b_p = \nabla\cdot\vb^n-S^{*,n+1}$ (note the change in sign!) 
and $\bb_\vb$ equal to the right-hand-side of (\ref{eq:CN Vel Pred}).  For the Helmholtz-like operator, 
$\mathcal{A}=\Theta\alpha\mathcal{I} - \mathcal{A}_0$, we have $\Theta=1/\Delta t, \alpha=\rho^{*,n+1}, 
\beta=\eta/2$, and $\gamma=\kappa/2$.\\ \\
{\bf Step 3: Trapezoidal Scalar Corrector:}
\begin{eqnarray}
\rho^{n+1} &=& \half\rho^n + \half\left[\rho^{*,n+1} + \Delta t\nabla\cdot(-\rho^{*,n+1}\vb^{*,n+1})\right],\\
\rho_1^{n+1} &=& \half\rho_1^n + \half\left[\rho_1^{*,n+1} + \Delta t\nabla\cdot(-\rho_1^{*,n+1}\vb^{*,n+1} + \Fb^{*,n+1})\right].
\end{eqnarray}
Note that $\Fb^{*,n+1}$ has already been computed during {\bf Step 2}.\\ \\
{\bf Step 4: Crank-Nicolson Velocity Corrector:}\\ \\
First, define
\begin{equation}
S^{n+1} \equiv S(\Fb^{n+1});
\qquad
\Fb^{n+1} = (\rho\chi\nabla c)^{n+1} + \underbrace{\sqrt{\frac{2\left[\chi\rho c(1-c)\right]^{n+1}}{\Delta t\Delta V}}\widetilde\Wb^{n+1}}_{\Psib^{n+1}}.
\end{equation}
Note the use of time-advanced stochastic concentration fluxes for use in $S$.  Finally, 
define $\vb^{n+1} = \vb^n + \deltab\vb$ and $\pi^{n+1} = \pi^n + \delta\pi$ and
solve the following system for $(\deltab\vb,\delta\pi)$:
\begin{eqnarray}
\left(\frac{\rho^{n+1}}{\Delta t} - \half\mathcal{A}_0^{n+1}\right)\deltab\vb + \nabla\delta\pi &=& \frac{(\rho^n-\rho^{n+1})\vb^n}{\Delta t} -\nabla\pi^n\nonumber\\
&&\hspace{-1.25in}+ \half\nabla\cdot(-\rho^n\vb^n\vb^n - \rho^{n+1}\vb^{*,n+1}\vb^{*,n+1}) + \half\left(\mathcal{A}^n_0\vb^n + \mathcal{A}^{n+1}_0\vb^n\right) + \nabla\cdot\Sigmab^n,
\end{eqnarray}
\begin{equation}
-\nabla\cdot\deltab\vb = \nabla\cdot\vb^n - S^{n+1}.
\end{equation}

\section{Boundary Conditions}
The types of non-periodic, ``physical'' boundary conditions we consider are 
(i) ``no-slip'' (impermeable) walls,
(ii) ``slip'' (impermeable) walls,
(iii) ``no-slip'' reservoir, and
(iv) ``slip'' reservoir conditions.
We impose boundary conditions on the primitive variables and velocities,
i.e., $\rho,c$, and $\vb$, and can convert these back to conservative
variables afterwards if needed.\\

{\bf No-Slip Wall:}  For any impermeable wall, the stochastic and diffusive
fluxes are both zero, $\rho\chi\partial c/\partial n = \Psi_n = 0$, as well as the 
advective flux, $\rho v_n = \rho_1 v_n = 0$.  The zero
diffusive flux implies a homogeneous Neumann condition on $c$ and also for $\rho$ since $\rho$
is derived from $c$ and the EOS.  The zero advective flux implies that $v_n=0$ on the
boundary.  The no-slip condition implies that each $v_{\tau}$ is a prescribed value
on the boundary.\\

{\bf Slip Wall:}  This is the same situation as the no-slip impermeable
wall, except that the tangential velocities are subject to the condition that the
traction, or tangential compoment of the normal viscous stress, is prescribed.
In other words, for each tangential direction $\tau$,
\begin{equation}
\eta\left(\frac{\partial v_n}{\partial\tau} + \frac{\partial v_{\tau}}{\partial n}\right) = f.\label{eq:free slip}
\end{equation}
Note that for walls with constant $v_n$ (including impermeable walls with $v_n=0$),
this condition reduces to $\partial v_{\tau}/\partial n=f/\eta$.  In most cases we
use a zero traction condition, where $f=0$.\\

{\bf No-Slip Reservoir:} We specify $c$ with a Dirichlet condition at the boundary, 
and use the EOS to obtain $\rho$ at the
boundary.  The normal velocity must be equal to $-(\rho^{-1}\beta)F_n$ in order for
the EOS to remain satisfied.  We must be careful with sequencing in a sense that
$F_n$ is not a function of $\vb$, so we can compute $F_n$ first and {\it then}
use this to directly specify $v_n$ on boundaries, making sure that the
subsequent GMRES solve preserves these boundary conditions.
The no-slip condition implies that each $v_{\tau}$ is
a prescribed value on the boundary.\\

{\bf Slip Reservoir:} This is the same situation as the no-slip reservoir, except
that each $v_{\tau}$ is subject to (\ref{eq:free slip}).  Since in general
the normal velocity is not constant in the tangential direction(s), we will have 
an inhomogeneous Neumann condition on each $v_{\tau}$, even if $f=0$.

\subsection{Implementation}

\subsubsection{Primitive Variables}
For all physical boundaries, the value of a primitive
variable on the boundary shall be stored in the ghost cell for convenience.  This
is true regardless of whether we use a homogeneous Neumann or Dirichlet condition.
For homogeneous Neumann, we simply copy the interior cell value, thus representing
a first-order extrapolation.  For Dirichlet conditions, we prescribe $c$ and use
the EOS to obtain $\rho$.  Note that the transport coefficients, $(\eta,\kappa,\chi)$,
are functions of the primitive variables, so when we compute them, we simply loop
over valid {\it and} ghost cells, and do not require special routines to fill
the ghost cells aftewards.  We fill ghost cells for primitive variables using the
subroutine, {\tt multifab\_physbc}.

\subsubsection{Velocities}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb]
\centering
\includegraphics[width=5.25in]{viscOp}
\caption{The stencils for the $x$-component of (Left) $\nabla\cdot\beta\nabla\vb$, (Middle) 
$\nabla\cdot\beta(\nabla\vb)^T$, and (Right) $\nabla\cdot[\mathcal{I}(\gamma-\frac{2}{3}\beta)(\nabla\cdot\vb)]$.  
The black circles indicate locations of $u$.
The black triangles indicate locations of $v$.
The red dots indicate the location of the $\beta$ and the gradients of velocity.}\label{fig:viscOp}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb]
\centering
\includegraphics[width=5.25in]{viscOp_3d}
\caption{The stencils for the $x$-component of (Left) $\nabla\cdot\beta\nabla\vb$, (Middle) 
$\nabla\cdot\beta(\nabla\vb)^T$, and (Right) $\nabla\cdot[\mathcal{I}(\gamma-\frac{2}{3}\beta)(\nabla\cdot\vb)]$.  
The black circles indicate locations of $u$.
The black triangles indicate locations of $v$ and $w$.
The red dots indicate the location of the $\beta$ and the gradients of velocity.}\label{fig:viscOp_3d}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
It is helpful to first consider the stencils for the viscous operators, as illustrated
in Figures \ref{fig:viscOp} and \ref{fig:viscOp_3d} for two and three dimensions.
There are a few key design principles to keep in mind:\\
\begin{itemize}
\item The viscous operator for faces {\it on} any physical boundary must
evaluate to zero, so it does not matter what value is stored for the normal component
of velocity in the ghost face immediately outside of the valid region, unless you 
are concerned 
about possible intermediate {\tt NaN} states that will later be overwritten.\\
\item The value of the normal velocity {\it on} the boundary {\it does} matter, since it
enters the stencil for the first interior normal velocity face and stencils for the
transverse velocity near the boundary.\\
\item The value of transverse velocities in ghost faces behind physical boundaries
{\it does} matter, since it enters the stencil for the interior transverse face.
We make sure to fill these using the appropriate physical boundary condition.\\
\item When setting normal velocities on physical boundaries, we don't have to worry
about corner ghost faces outside of the domain.  Those only matter if we are periodic 
in the transverse
direction, in which case the call to {\tt multifab\_fill\_boundary} should take care of
these periodic values.\\
\item When setting transverse velocity ghost faces behind physical boundaries, we do
not have to worry about ghost faces that are outside the valid region with respect
to the problem domain in the transverse direction.  Those only matter if we are 
periodic in the transverse direction, in which case the call to {\tt multifab\_fill\_boundary}
should take care of these periodic values.\\
\end{itemize}

We carry around several auxiliary multifabs that store the Dirichlet value on the
boundary, whether they are homogeneous or inhomogeneous.  To deal with normal 
velocities, the multifab {\tt vel\_bc\_n(nlevs,dm)}
stores the actual Dirichlet value.  The $(n,d)^{\rm th}$ element is a face-centered
multifab for refinement level $n$ in direction $d$ and does not require ghost cells.\\

To deal with transverse velocities, the multifab {\tt vel\_bc\_t(nlevs,X)} stores
either the Dirichlet or Neumann value (depending on the boundary type), for both 
inhomogeneous and homogeneous cases.  In 2D, X=2,
and in 3D, X=6.  In 2D, the multifabs are each nodal and the components represent:\\
\begin{enumerate}
\item The y-velocity bc on x-faces.
\item The x-velocity bc on y-faces.\\
\end{enumerate}

In 3D, the multifabs are edge-based (i.e., nodal in 2 directions)
and the components represent:\\
\begin{enumerate}
\item The y-velocity bc on x-faces (thus is nodal in y and x).
\item The z-velocity bc on x-faces (thus is nodal in z and x).
\item The x-velocity bc on y-faces (thus is nodal in x and y).
\item The z-velocity bc on y-faces (thus is nodal in z and y).
\item The x-velocity bc on z-faces (thus is nodal in x and z).
\item The y-velocity bc on z-faces (thus is nodal in y and z).\\
\end{enumerate}

Note that none of these multifabs require any ghost cells.\\

We have two subroutines that deal with velocity boundary conditions.  Each of these
take in an optional multifab argument that represents the prescribed Dirichlet
or Neumann value on the
boundary.  Note that this can either refer to the prescribed value
of normal velocity on the boundary, or a Dirichlet {\it or} Neumann
condition used to determine the ghost face values for transverse velocity.
If no multifab is passed in, it is assumed that the boundary conditions
are homogeneous.  The subroutine {\tt multifab\_physbc\_domainvel} sets the 
value for faces on the boundary and can take {\tt vel\_bc\_n} as an input.
The subroutine {\tt multifab\_physbc\_macvel}
sets the transverse velocity ghost faces behind the physical boundary and
can take {\tt vel\_bc\_t} as an input.\\

For {\tt multifab\_physbc\_domainvel}, the optional multifab that gets passed in
must be face-centered, and requires no ghost cells.  The boundary face itself
stores the Dirichlet value.\\

For {\tt multifab\_physbc\_macvel}, the optional multifab that gets passed in
must be nodal in exactly 2 directions.
We use the domain value to represent
the Dirichlet or Neumann value, and then depending on the boundary conditions, the 
appropriate stencil is used to fill in the ghost value.
The stencil for transverse velocities is a two-point stencil involving the
interior value and the Dirichlet or Neumann boundary value.\\

We need to write a helper routine to compute the Neumann condition in the case of
free-slip walls or free-slip reservoirs.  This only matters if the normal velocity
changes as a function of the transverse velocity of interest.  If not, a 
homogeneous Neumann condition is correct.\\

\subsubsection{GMRES Boundary Conditions}
The GMRES solver assumes homogeneous boundary conditions,
so we use a residual correction technique to convert the problem to one
with homogeneous boundary conditions of the same type (Neumann or Dirichlet):
\begin{equation}
\Ab_H\xb = \bb - \Ab\xb_H.
\end{equation}
Here, $\Ab_H$ is the same operator as $\Ab$, but with homogeneous boundary conditions
of the same type.
The vector $\xb_H$ is a vector with zeros in all valid cells (but possibly
non-zero values in the ghost cells, depending on the boundary conditions).
By solving this system for $\xb$, we arrive at the same answer as solving the
inhomogeneous problem, $\Ab\xb=\bb$.

It is also important to note that we are solving a ``delta'' formulation for
$(\deltab\vb,\delta\pi)$.  This means we have to be careful when supplying
a boundary condition to the subroutine that converts the problem to a homogeneous
problem, in that for time-dependent boundary conditions (such as reservoirs), we
must supply the {\it change} in the velocity boundary condition, rather than
the final velocity boundary condition itself.

\end{document}
